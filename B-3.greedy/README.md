

매 순간 지역적으로 최적의 답이 모였을 때 전역적으로 최적의 답이 나올 때 사용한다.

아래의 두 가지 조건을 만족해야한다.
- 탐욕적 선택 속성(Greedy Choice Property): 지금 이 순간 최선의 선택을 하면 나중에 이전의 선택을 번복할 필요가 없는 구조이다.
- 최적 부분 구조(Optimal Substructure): 전체 문제의 최적해는 부분 문제에 대한 최적해들로 구성된다. DP 와 공유하는 속성이다.

아래 절차로 풀이를 접근한다. 최소의 동전 수로 amount를 만든다고 했을 때
- 선택 절차(Selection Procedure): 현재 상태에서의 최적의 해답을 선택한다. 비싼 동전일수록 적게 사용할 수 있으므로 가장 비싼 500원짜리를 고른다.
- 적절성 검사(Feasibility Check): 선택된 해가 문제의 조건을 만족하는지 검사한다. 500원을 선택했을 때 target amount를 넘지 않는지 확인한다. 넘으면 다시 1번으로 가서 동전을 고른다.
- 해답 검사(Solution Check): 원래의 문제가 해결되었는지 검사하고, 해결되지 않았다면 선택 절차로 돌아가 위의 과정을 반복한다. 동전을 골랐으면 그 값이 amount인지 확인한다.

그런데 이거는 특수한 케이스인 것 같다. 만약 동전이 20, 30만 있고 70을 만든다고 하면 30 + 30 을 골라버리게 되고 그 다음에는 답을 못 구하게 된다. 동전들이 서로 배수 관계일 때만 가능하다.      
일반적으로는 dp를 쓰는 게 맞다. dp의 coin change 문제 참고.


그리디는 그래프와 데이터 압축 분야에서 강력한 힘을 발휘한다.
- 그래프
  - Kruskal's & Prim's: 최소 신장 트리(MST)를 구할 때 사용. (가장 짧은 간선부터 선택)
  - Dijkstra's: 최단 경로를 찾을 때 사용. (방문하지 않은 노드 중 가장 가까운 노드 선택)
- 데이터 압축: * Huffman Coding: 빈도수가 높은 문자에 짧은 코드를 부여하는 탐욕적 기법.
- 스케줄링: * Activity Selection: 가장 빨리 끝나는 회의를 먼저 선택하는 방식.



